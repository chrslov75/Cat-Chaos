<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cat Chaos Defender üê±üè†</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Cat Chaos">
    <meta name="theme-color" content="#FFE4E1">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(to bottom, #FFE4E1, #DDA0DD);
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #F5F5DC;
            touch-action: none;
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #333;
            font-size: clamp(14px, 4vw, 20px);
            font-weight: bold;
            z-index: 10;
            max-width: 90%;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
            pointer-events: none;
        }
        @media (orientation: landscape) { #instructions { top: 5%; } }
    </style>
</head>
<body>
    <div id="instructions">
        üè† Tap cats to scare them before they knock over glasses ü•õ & lamps üí°!<br>
        Watch out for <span style="color:#000;">Kermit üêà‚Äç‚¨õ</span> ‚Äì he throws glasses! üëÜ
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        });

        let gameRunning = true;
        let score = localStorage.getItem('catChaosScore') ? parseInt(localStorage.getItem('catChaosScore')) : 0;
        let highScore = localStorage.getItem('catChaosHigh') ? parseInt(localStorage.getItem('catChaosHigh')) : 0;
        let lives = 5;
        let items = [];
        let cats = [];
        let projectiles = [];
        let frame = 0;
        let spawnTimer = 0;
        let spawnInterval = 100;
        let knockX = canvas.width * 0.7;
        let table = { x: canvas.width * 0.65, y: canvas.height * 0.65, w: canvas.width * 0.25, h: canvas.height * 0.08 };
        let lanes = [canvas.height * 0.4, canvas.height * 0.48, canvas.height * 0.55, canvas.height * 0.65];

        const types = ['oscar', 'nibbles', 'dusty', 'chester', 'kermit'];
        const catEmojis = { oscar: 'üê±', nibbles: 'üêà', dusty: 'üêà', chester: 'üê±', kermit: 'üêà‚Äç‚¨õ' };

        function initItems() {
            items = [];
            lives = 5;
            for (let i = 0; i < 5; i++) {
                items.push({
                    x: table.x + 10 + i * (table.w / 6),
                    y: table.y - 40,
                    type: Math.random() > 0.5 ? 'glass' : 'lamp'
                });
            }
        }

        function spawnCat() {
            const type = types[Math.floor(Math.random() * types.length)];
            const isKermit = type === 'kermit';
            const vx = (1.2 + Math.random() * 0.6 + (isKermit ? 1.2 : 0)) * (canvas.width / 800);
            const laneIdx = Math.floor(Math.random() * lanes.length);
            const y = lanes[laneIdx];
            cats.push({ x: -60, y, vx, type, scared: false, projFrame: Math.floor(Math.random() * 80) });
        }

        function update() {
            if (!gameRunning) return;
            frame++;
            spawnTimer++;
            spawnInterval = Math.max(30, 100 - Math.floor(score / 50));
            if (spawnTimer > spawnInterval) { spawnCat(); spawnTimer = 0; }
            knockX = canvas.width * 0.7;

            for (let i = cats.length - 1; i >= 0; i--) {
                const cat = cats[i];
                cat.x += cat.vx;
                if (cat.scared) {
                    if (cat.x < -100) cats.splice(i, 1);
                } else {
                    if (cat.type === 'kermit') {
                        cat.projFrame++;
                        if (cat.projFrame >= 80) {
                            projectiles.push({ x: cat.x + 25, y: cat.y + 5, vx: cat.vx + 2 });
                            cat.projFrame = 0;
                        }
                    }
                    if (cat.x > knockX) { knockItem(); cats.splice(i, 1); }
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += proj.vx;
                if (proj.x > knockX) { knockItem(); projectiles.splice(i, 1); }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            const wallY = canvas.height * 0.4 / dpr;
            ctx.fillStyle = '#E0D7C0';
            ctx.fillRect(0, 0, canvas.width / dpr, wallY);
            ctx.fillRect(0, wallY, canvas.width * 0.15 / dpr, canvas.height / dpr - wallY);
            ctx.fillRect(canvas.width * 0.85 / dpr, wallY, canvas.width * 0.15 / dpr, canvas.height / dpr - wallY);

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, canvas.height * 0.85 / dpr, canvas.width / dpr, canvas.height * 0.15 / dpr);

            ctx.fillStyle = '#D2691E';
            ctx.fillRect(table.x / dpr, table.y / dpr, table.w / dpr, table.h / dpr);
            ctx.fillStyle = '#A0522D';
            ctx.fillRect((table.x + 10) / dpr, (table.y + 10) / dpr, (table.w - 20) / dpr, (table.h - 20) / dpr);

            items.forEach(item => {
                ctx.save();
                ctx.translate(item.x / dpr, item.y / dpr);
                ctx.scale(1.2, 1.2);
                ctx.font = 'bold 38px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(item.type === 'glass' ? 'ü•õ' : 'üí°', 0, 25);
                ctx.restore();
            });

            cats.forEach(cat => {
                ctx.save();
                const scaleX = cat.scared ? -1.3 : 1.3;
                ctx.scale(scaleX, 1.3);
                ctx.font = 'bold 52px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(catEmojis[cat.type], (cat.x / dpr) / scaleX, cat.y / dpr);
                ctx.restore();
            });

            projectiles.forEach(proj => {
                ctx.save();
                ctx.translate(proj.x / dpr, proj.y / dpr);
                ctx.scale(1.1, 1.1);
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ü•õ', 0, 25);
                ctx.restore();
            });

            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'left';
            ctx.font = `bold ${Math.min(48, canvas.width / 16 / dpr)}px Arial`;
            ctx.fillText(`Score: ${score}`, 20, 55);

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('catChaosHigh', highScore);
            }

            ctx.textAlign = 'center';
            for (let i = 0; i < lives; i++) {
                ctx.font = `bold ${Math.min(42, canvas.width / 18 / dpr)}px Arial`;
                ctx.fillText('‚ù§Ô∏è', (table.x + i * 50) / dpr, 55);
            }

            ctx.font = `bold ${Math.min(24, canvas.width / 32 / dpr)}px Arial`;
            ctx.fillText(`High: ${highScore}`, canvas.width / 2 / dpr, 55);

            if (!gameRunning) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
                ctx.fillStyle = '#FFF';
                ctx.textAlign = 'center';
                ctx.font = `bold ${Math.min(64, canvas.width / 12 / dpr)}px Arial`;
                ctx.fillText('Game Over! üê±üí•', canvas.width / 2 / dpr, canvas.height / 2 / dpr - 50);
                ctx.font = `bold ${Math.min(36, canvas.width / 22 / dpr)}px Arial`;
                ctx.fillText(`Score: ${score}`, canvas.width / 2 / dpr, canvas.height / 2 / dpr);
                ctx.fillText(`High: ${highScore}`, canvas.width / 2 / dpr, canvas.height / 2 / dpr + 40);
                ctx.font = `bold ${Math.min(28, canvas.width / 28 / dpr)}px Arial`;
                ctx.fillText('Tap to Restart', canvas.width / 2 / dpr, canvas.height / 2 / dpr + 100);
            }
        }

        function knockItem() {
            if (lives > 0) {
                lives--;
                if (items.length) {
                    const idx = Math.floor(Math.random() * items.length);
                    items.splice(idx, 1);
                }
            }
            if (lives <= 0) gameOver();
        }

        function gameOver() {
            gameRunning = false;
            localStorage.setItem('catChaosScore', score);
        }

        function resetGame() {
            gameRunning = true;
            score = 0;
            frame = 0;
            spawnTimer = 0;
            cats = [];
            projectiles = [];
            initItems();
            spawnCat();
        }

        function handleTap(e) {
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const scaledX = clientX * (canvas.width / window.innerWidth);
            const scaledY = clientY * (canvas.height / window.innerHeight);

            if (!gameRunning) {
                resetGame();
                return;
            }

            for (let i = cats.length - 1; i >= 0; i--) {
                const cat = cats[i];
                const dx = scaledX - cat.x;
                const dy = scaledY - cat.y;
                if (dx * dx + dy * dy < 1600) {
                    cat.scared = true;
                    cat.vx = -4.5 - Math.random() * 0.5;
                    score += 10;
                    return;
                }
            }
        }

        canvas.addEventListener('touchstart', handleTap, { passive: false });
        canvas.addEventListener('click', handleTap);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) localStorage.setItem('catChaosScore', score);
        });

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        initItems();
        spawnCat();
        gameLoop();
    </script>
</body>
</html>